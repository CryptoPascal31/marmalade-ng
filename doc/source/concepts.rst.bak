Concepts and architecture
=========================

Archiecture
------------

Security Model
--------------

The security model of Marmalade-NG is based on the following principles.

Simplicity
~~~~~~~~~~
The architecture model is simple.
It leaves only the minimum possible in the ledger module.

There are no associated centralized ``policy-manager`` or ``quote-manager`` as in Marmalade V2:
   - Every circular dependencies are avoided
   - Multiply Singles Point of Failure, with added complexity

Most of the business logic resides in policies


Policies isolation
~~~~~~~~~~~~~~~~~~
Thanks to Pact capabilities, all policies and hooks inside are isolated from each other.
   - Prevent cross-tokens calls
   - Prevent cross-policies calls
   - Prevent cross-hooks calls inside a single policy

All the standards policies use the same paradigm: avoid any dependencies between policies.
As a rule of thumb, policies must stay independent from each other, without the need to use external data from other policies.

This guarantees that most of bugs and possible security breach inside a policy (even a custom one) will have a limited range and a limited exploitability.

Sales escrow account
~~~~~~~~~~~~~~~~~~~~
During a sale escrow accounts are necessary.
The Marmalade-NG architecture provides a suitable framework for policies to deal with such accounts.

The architecture try to reduce as much as possible the code range where debiting escrow accounts is possible.
This has been done by breaking the *buy operation* into 2 steps.


Front-running considerations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In the Maramalade-NG, front-running attacks that could lead to a loss of funds or a Denial of Service are considered.

Especially these two critical cases are considered:
  - tokens creation
  - collections creation


Token IDs
---------
The primary key to identify tokens is the tokenID.

This ID always starts with a "t:" and is a hash of the concatenation of:
   - The URI of the NFT
   - A creation guard

The creation guard may be a key, but also another (well protected) guard when a token is created by a contract.

The creation guard prevents front-running and ensures that only the legit creator will be able to create a token with a giben token-id.

The token-id can be pre-generated by calling ``(ledger.create-token-id)``


Policies
--------
When created the token must *subscribe* to a list of policies.

These policies can be:
  - standard policies
  - custom policies

A policy is a Pact helper module that will be called at each step of the life of the token. A policy must implement the token-policy interface

.. code:: lisp

   (interface token-policy-v2

     (defschema token-info
       id:string
       supply:decimal
       precision:integer
       uri:string
     )

     (defun rank:integer ()
       @doc "Returns the rank of the policy"
     )

     (defun enforce-init:bool (token:object{token-info})
       @doc "Enforce policy on TOKEN initiation."
     )

     (defun enforce-mint:bool (token:object{token-info} account:string amount:decimal)
       @doc "Minting policy for TOKEN to ACCOUNT for AMOUNT."
     )

     (defun enforce-burn:bool (token:object{token-info} account:string amount:decimal)
       @doc "Burning policy for TOKEN to ACCOUNT for AMOUNT."
     )

     (defun enforce-transfer:bool (token:object{token-info} sender:string receiver:string amount:decimal)
       @doc "Enforce rules on transfer of TOKEN AMOUNT from SENDER to RECEIVER"
     )

     (defun enforce-sale-offer:bool (token:object{token-info} seller:string amount:decimal timeout:time)
       @doc "Offer policy by SELLER of AMOUNT of TOKEN."
     )

     (defun enforce-sale-withdraw:bool (token:object{token-info})
       @doc "Withdraw policy by SELLER of AMOUNT of TOKEN"
     )

     (defun enforce-sale-buy:bool (token:object{token-info} buyer:string)
       @doc "Buy policy to BUYER AMOUNT of TOKEN."
     )

     (defun enforce-sale-settle:bool (token:object{token-info})
       @doc "Settle of TOKEN."
     )
   )


For each operation (*eg:* a transfer), the ledger calls the corresponding hook of every policy attached to the token.

A policy hook can:
  - Check the allowed usage of a token and make the transaction fail if one the conditions is not respected by using a Ã¢ct ``(enforce)``
  - Doing much complicated things, like storing data, moving funds, manage a sale.

The calling order of the policies is set-up by a special function ``(rank)`` that all policies should implement.

For most hook the return value (a bool) is not checked.

As a consequence a hook must:
 - return ``true`` or ``false`` if evrything is ok.
 - or make the transaction fail by a false enforcement.

Important: The only exception for the hook ``(enforce-sale-offer)``. The policy must:
  - make the transaction fail if the sale is not allowed
  - return ``false`` if he accepts the sale but does not handle it.
  - return ``true`` only if the policy has chosen to handle the sale.

The ledger enforces that at least 1 policy has handled the sale.

This is necessary to prevent the dramatic case when no policy wants to manage the sale.

Example:


Passing data to policies
------------------------
Since the poly-fungible API does not allow to pass specific informations to the policies, parameters must
be passed by using the data section of the transaction.

Marmalade-NG uses a standardized way to encode the data.

All data are objects defined in the Policies using a `defschema`.

The key that references these objects in the transaction can have 2 possibles formats:
  - *marmalade_${domain}_{tokenId}*
  - *marmalade_${domain}*

where ${domain} is a key defined by the policy.

The first syntax allow to define data related to a specific token. It covers the cases
when several tokens are handled in the same transaction but with different parameters.

The second syntax acts as a fallback and allow to define a common set of paramaters for all tokens.

Example: Imagine a transaction that create two tokens but with different royalty rates:

.. code-block:: lisp
  :caption: Pact code

  (use marmalade-ng.ledger)
  (use marmalade-ng.std-policies)
  (create-token "t:L3JH94fXZQvUZ_IGNKMXAX5HwSZc_X0H7OwbnY_lsHA" 0
                 "https://red-tulips.com/tulip-1"
                 (to-policies "DISABLE-TRANSFER ROYALTY")
                 (keyset-ref-guard "user.creator"))

  (create-token "t:9Dh2pSjMjXLPERZnbE-aDuXQuquuOkgxSOgS-hYYX7Q" 0
                "https://red-tulips.com/tulip-1"
                (to-policies "DISABLE-TRANSFER ROYALTY")
                (keyset-ref-guard "user.creator"))


.. code-block:: json
   :caption: Transaction data

   {"marmalade_royalty_t:L3JH94fXZQvUZ_IGNKMXAX5HwSZc_X0H7OwbnY_lsHA":
         {"creator_acct":"k:9ded186eb20c495ca1f08d59722237024282da264db1ed8d5aaf4ca4d351edd0",
          "creator_guard":{"pred":"keys-all",
                           "keys":["9ded186eb20c495ca1f08d59722237024282da264db1ed8d5aaf4ca4d351edd0"]},
          "rate": 0.05 },
    "marmalade_royalty_t:9Dh2pSjMjXLPERZnbE-aDuXQuquuOkgxSOgS-hYYX7Q":
          {"creator_acct":"k:9ded186eb20c495ca1f08d59722237024282da264db1ed8d5aaf4ca4d351edd0",
           "creator_guard":{"pred":"keys-all",
                            "keys":["9ded186eb20c495ca1f08d59722237024282da264db1ed8d5aaf4ca4d351edd0"]},
           "rate": 0.2 }
    }



Sales
-----
In Marmalade-NG, the sale process has been a lot improved compared to Marmalade-V2.

The Marmalade-NG core only does the minimum

During a sale, the ledger managaes:
  - The transmission of the token itself
  - The escrow accounts guard
  - Delegates most processing to the policies by calling the 4 related sales hooks

Step 1:
~~~~~~~
User start the defpact by calling ``(sale)``.

In this transaction, by convention the user include a ``marmalde_sale`` object in the data section
of the transaction:

.. code:: lisp

  (defschema sale-msg-sch
    sale_type:string ; Type of sale
    currency:module{fungible-v2} ; Currency of sale
  )

All "sales managing policy" are required to recognize this object and get triggered when
they recognize the right ``sale_type`` they support.

Each policy's hook ``(enforce-sale-offer)`` is being called.
At least one policy must answer ``true``.  Usually the policy stores the sales parameters for the next steps.

The ledger move the token ammount being sold to the escorw account.


Steps between 1 and 2:
~~~~~~~~~~~~~~~~~~~~~~
Some policies may require some extra step before ending the sale (eg: bbidding for an auction sale).

But this a direct interraction between users and the policy and not managed by the Marmalade-NG core and the ledger.


Step 2:
~~~~~~~
An user call the defpact continuation. The transaction data section must include the fields
``buyer`` and ``buyer-guard`` to indicate teh destination account of the token.

Each policy's hook ``(enforce-sale-buy)`` is being called.

Usually the objective of this hook is to:
  - Doing evry needed verification to allow the sale to be ended
  - Transfer the funds to an escrow account

Then the ledger transfer the token to the buyer account.

Each policy's hook ``(enforce-sale-settle)`` is being called. During these call, the
escrow accounts are unlocked, allowing the policy to make the needed payments:

- to the seller

- to the market place

- to the creator (royalties)

- ...

Here, we can see the importance of the rank of the policy, as the order where policies are called is important.


Withdraw step (alternative to step 2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Alternatively, the sale can be canceled. During a cancelation (rollback of the defpact), the ``(enforce-sale-withdraw)`` hooks
are being called.

If all the polcies allow the withdrawal, the token is transferred back from the escrow account to the seller.
